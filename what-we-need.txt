# Event Transform Architecture for Future TileDB Integration

## Summary of Current System Issues

The current `t2E_event_v0.py` transform (EventTransform) has several issues:

1. **NULL pointer errors** - The most critical issue is in the `_convert_to_array` method where NULL values in array fields like 'recording_segments', 'thinking_segments', and 'pause_segments' cause errors when creating H5 datasets
2. **Inconsistent event data handling** - Events are processed in different ways with complex matching logic
3. **Limited metadata and relations** - The current approach doesn't fully capture the rich event relationships that would enable flexible TileDB querying

## Requirements for Ideal Event Transform

### 1. Core Data Structure Requirements

The ideal event transform should extract and organize events into a structure that supports:

- **Time alignment** - All events should be precisely time-aligned to support windowing and querying
- **Event hierarchy** - Maintain parent-child relationships (tasks → elements → segments)
- **Event categorization** - Group similar events (recording segments, thinking segments, etc.)
- **Comprehensive metadata** - Include rich metadata for all events to enable filtering
- **Reference integrity** - Maintain relationships between different event types
- **NULL safety** - Properly handle missing/NULL values to avoid array creation errors

### 2. Event Data Model

Based on examining the code and H5 files, the following data model should be used:

#### Tasks
- **Definition**: High-level activities (eye tracking, breathing, word entry, etc.)
- **Relationships**: Contains elements, spans time ranges
- **Key fields**: task_id, task_type, sequence_number, start_time, end_time, configuration parameters
- **Examples**: eye_1, breath_1, word_1, etc.

#### Elements
- **Definition**: Individual steps/components within tasks
- **Relationships**: Belongs to a task, spans time ranges, may contain segments
- **Key fields**: element_id, element_type, task_id, start_time, end_time, stimulus content
- **Examples**: Instructions, prompts, user input fields

#### Segments
- **Definition**: Specific time periods with particular activity (recording, thinking, pausing)
- **Relationships**: May be contained within elements or tasks
- **Key fields**: segment_id, segment_type, start_time, end_time, containing_element_id/task_id

### 3. Required Queries for TileDB Integration

The event data structure should support these types of queries:

1. **Time-based queries**:
   - Get all events during a specific time period
   - Get events that overlap with specific neural data windows

2. **Task-based queries**:
   - Get all elements for a specific task type (e.g., all eye-tracking tasks)
   - Get all recording segments during a specific task

3. **Element-based queries**:
   - Get all elements of a specific type (e.g., all instructions)
   - Get neural data windows that align with specific elements

4. **Segment-based queries**:
   - Get all recording segments across the session
   - Get neural data during specific activity segments (thinking, recording)

5. **Combined/Cross-cutting queries**:
   - Get all EEG data from the second eyes-open element in the first eyes task
   - Get all FNIRS data during thinking segments across the session
   - Get windowed data only around specific tokens

### 4. TileDB Data Organization Strategy

To support the above queries, the TileDB dataset should be organized with:

1. **Time as primary dimension**:
   - All events indexed by start_time and end_time
   - Enables efficient time-based queries and windowing

2. **Hierarchical dimensions**:
   - Task type/ID
   - Element type/ID
   - Segment type/ID

3. **Metadata attributes**:
   - All additional fields as queryable attributes
   - Configuration parameters
   - Relationship information (containment, IDs)

4. **Array structure recommendations**:
   - Sparse arrays for event time ranges (start/end times)
   - Dense arrays for continuous neural data
   - Dimension-based filtering for fast queries

### 5. Specific Improvements Needed for Event Transform

The current event transform needs these specific improvements:

1. **Robust NULL handling**:
   - Ensure all arrays are initialized properly (never NULL)
   - Add safety checks before creating variable-length arrays
   - Implement proper type conversions for array fields

2. **Event relationship modeling**:
   - Create more complete relationship indices
   - Store bidirectional references (parent→child and child→parent)
   - Support querying "what element contains this segment?" and vice versa

3. **Enhanced metadata**:
   - Add explicit event type categorization
   - Include metadata about original event sources
   - Add timing statistics (duration, relative position)

4. **Temporal alignment**:
   - Ensure consistent timestamp handling across event types
   - Include session-relative timing information
   - Add support for calculating overlaps between events

5. **Structure standardization**:
   - Consistent field naming across event types
   - Structured format for configuration parameters
   - Enumerated event types and statuses

6. **Query optimization**:
   - Pre-build common indices (by type, by time range, by relationship)
   - Include count/summary statistics
   - Add fields that will enable direct TileDB dimension mapping

### 6. Implementation Approach

1. **Fix immediate NULL pointer issues**:
   - Update the `_convert_to_array` method to properly handle NULL values
   - Add explicit initialization for array fields
   - Add type checking and conversion for array elements

2. **Enhance data extraction**:
   - Improve event pairing logic with more robust matching
   - Handle edge cases like incomplete event pairs
   - Add validation for timestamp consistency

3. **Expand relationship modeling**:
   - Create more comprehensive indices between events
   - Store both forward and reverse relationships
   - Add spatial relationship information (contains, overlaps, etc.)

4. **Add TileDB-specific optimizations**:
   - Include dimension info that maps directly to TileDB schema
   - Add fields that support efficient filtering in TileDB
   - Create optimal grouping of related events

5. **Improve H5 file structure**:
   - Organize for efficient query patterns
   - Include summary tables for quick access
   - Store metadata that will inform TileDB schema creation

### 7. Key Architectural Decisions

1. **Handle special event pairs (element_sent/replied, task_started/completed)**:
   - Recognize that these form logical units (one full element or task)
   - Store both individual events and their combined representation
   - Include relationship metadata to navigate between representations

2. **Distinguish one-shot vs. duration events**:
   - One-shot events (display, keystroke) stored with single timestamp
   - Duration events (task, element, segment) stored with start/end times
   - Include event type categorization to enable appropriate queries

3. **Flexible session time representation**:
   - Store absolute timestamps for precise alignment
   - Include session-relative times for easier querying
   - Add normalized time fractions for cross-session comparison

4. **Event hierarchy standardization**:
   - Consistent task → element → segment hierarchy
   - Handle cases where segments span multiple elements
   - Support orphaned events that don't fit the hierarchy

5. **NULL and missing value strategy**:
   - Empty arrays instead of NULL pointers
   - Default values for missing fields
   - Explicit indicators for data availability

### 8. Conclusion

A well-designed event transform is essential for enabling efficient and flexible queries when data is integrated into TileDB. By addressing the NULL pointer issues, enhancing relationship modeling, and optimizing the data structure for common query patterns, the event transform will provide a solid foundation for the eventual TileDB integration.

The most urgent issue to fix is the NULL pointer problem in `_convert_to_array`, but a comprehensive redesign should also consider the broader requirements of downstream TileDB usage to ensure the extracted event data is optimally structured for future queries.